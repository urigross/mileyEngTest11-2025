<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>××©×—×§×™× ×œ×™××•×“×™×™× GGGG</title>
    <style>
        :root {
            --primary-color: #4CAF50;
            --secondary-color: #2196F3;
            --accent-color: #FF9800;
            --bg-color: #f4f7f6;
            --text-color: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            background-color: var(--bg-color);
            margin: 0;
            padding: 15px;
            box-sizing: border-box;
            color: var(--text-color);
            user-select: none; /* ×× ×™×¢×ª ×‘×—×™×¨×ª ×˜×§×¡×˜ ×‘×˜×¢×•×ª */
        }

        h1 { margin-bottom: 5px; color: #444; }

        /* --- ××—×•×•×Ÿ ×”×ª×§×“××•×ª --- */
        .progress-container {
            max-width: 320px;
            margin: 10px auto 25px auto;
            background-color: #e0e0e0;
            border-radius: 25px;
            overflow: hidden;
            height: 25px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background-color: var(--primary-color);
            text-align: center;
            line-height: 25px;
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
            transition: width 0.5s ease-in-out;
        }

        /* --- ×ª×¤×¨×™×˜ ×¨××©×™ --- */
        #main-menu {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 400px;
            margin: 0 auto;
            width: 100%;
        }

        .menu-btn {
            width: 100%;
            padding: 18px;
            font-size: 1.4rem;
            cursor: pointer;
            border: none;
            border-radius: 18px;
            background-color: white;
            color: var(--text-color);
            box-shadow: 0 4px 0px rgba(0,0,0,0.1);
            border: 2px solid #eee;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .menu-btn:active { transform: translateY(4px); box-shadow: none; }
        
        /* ×¦×‘×¢×™× ×™×™×—×•×“×™×™× ×œ×›×¤×ª×•×¨×™× */
        .btn-snake { border-right: 10px solid var(--primary-color); }
        .btn-tf { border-right: 10px solid var(--secondary-color); }
        .btn-memory { border-right: 10px solid var(--accent-color); }
        .btn-settings { border-right: 10px solid #607d8b; background-color: #eceff1; margin-top: 20px; }

        /* --- ××–×•×¨×™ ×”××©×—×§ --- */
        .game-container, #settings-screen {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .active { display: block; }
        .back-btn { background-color: #f5f5f5; color: #555; border: 1px solid #ddd; margin-top: 20px; font-size: 1.1rem; padding: 12px; }

        /* --- ×¢×™×¦×•×‘ ×××ª ××• ×©×§×¨ --- */
        #tf-image-container { min-height: 220px; display: flex; align-items: center; justify-content: center; margin: 10px 0; }
        #tf-image-container img { max-width: 100%; max-height: 200px; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .tf-buttons { display: flex; gap: 15px; }
        .tf-btn { flex: 1; padding: 20px; font-size: 1.5rem; border: none; border-radius: 15px; cursor: pointer; color: white; box-shadow: 0 4px 0 rgba(0,0,0,0.2); }
        .tf-btn:active { transform: translateY(4px); box-shadow: none; }
        .btn-true { background-color: var(--primary-color); }
        .btn-false { background-color: #f44336; }

        /* --- ×¢×™×¦×•×‘ ×¡× ×™×™×§ --- */
        #snake-board {
            width: 300px; height: 300px; background-color: #2c3e50; margin: 10px auto;
            position: relative; border-radius: 10px; box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        .snake-part { width: 20px; height: 20px; background-color: #2ecc71; position: absolute; border-radius: 4px; box-shadow: 0 0 5px #2ecc71; }
        .food-item { width: 20px; height: 20px; background-color: #e74c3c; position: absolute; border-radius: 50%; box-shadow: 0 0 8px #e74c3c; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }

        /* --- ×¢×™×¦×•×‘ ××©×—×§ ×”×–×™×›×¨×•×Ÿ --- */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 ×¢××•×“×•×ª */
            gap: 10px;
            margin: 20px 0;
        }
        .memory-card {
            background-color: #2196F3;
            border-radius: 10px;
            height: 90px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.3s;
            box-shadow: 0 3px 0 #1976D2;
        }
        .memory-card.flipped { background-color: white; color: #333; border: 2px solid #2196F3; }
        .memory-card img { max-width: 80%; max-height: 80%; }
        .memory-card.matched { background-color: #4CAF50; border-color: #4CAF50; opacity: 0.5; pointer-events: none; }

        /* --- ×”×’×“×¨×•×ª --- */
        .settings-group { text-align: right; padding: 15px; background: #fff; border-bottom: 1px solid #eee; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; vertical-align: middle; margin-left: 10px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(22px); }

    </style>
</head>
<body>

    <h1>××©×—×§×™× ×œ×™××•×“×™×™×</h1>
    <div class="progress-container">
        <div id="progress-fill" class="progress-fill">0%</div>
    </div>

    <div id="main-menu" class="active">
        <button class="menu-btn btn-snake" onclick="showGame('snake')">
            <span>ğŸ</span> ×¡× ×™×™×§ ××™×œ×™×
        </button>
        <button class="menu-btn btn-tf" onclick="showGame('truefalse')">
            <span>âœ…</span> ×××ª ××• ×©×§×¨
        </button>
        <button class="menu-btn btn-memory" onclick="showGame('memory')">
            <span>ğŸ§©</span> ××©×—×§ ×”×–×™×›×¨×•×Ÿ
        </button>
        <button class="menu-btn btn-settings" onclick="showSettings()">
            <span>âš™ï¸</span> ×”×’×“×¨×•×ª ××¢×¨×›×ª
        </button>
    </div>

    <div id="settings-screen">
        <h2>×”×’×“×¨×•×ª</h2>
        <div class="settings-group">
            <label class="switch">
                <input type="checkbox" id="progressive-toggle" onchange="toggleProgressiveMode()">
                <span class="slider"></span>
            </label>
            <strong>×œ××™×“×” ×¤×¨×•×’×¨×¡×™×‘×™×ª</strong>
            <p style="font-size:0.9rem; color:#666;">×›××©×¨ ×¤×¢×™×œ: ××™×œ×™× ×©× ×œ××“×• ×œ× ×™×•×¤×™×¢×• ×©×•×‘.</p>
        </div>
        <div class="settings-group">
            <button id="reset-progress-btn" class="menu-btn" style="background-color:#ff5252; color:white; border:none;" onclick="resetProgress()" disabled>
                ××™×¤×•×¡ ×”×ª×§×“××•×ª â†º
            </button>
        </div>
        <button class="menu-btn back-btn" onclick="showMainMenu()">×—×–×•×¨ ×œ×ª×¤×¨×™×˜</button>
    </div>

    <div id="snake-game" class="game-container">
        <h2>×¡× ×™×™×§ ××™×œ×™×</h2>
        <p>××›×•×œ ××ª ×”××™×œ×”: <span id="target-word-snake" style="font-weight:bold; color:var(--secondary-color); font-size:1.4rem;"></span></p>
        <div id="snake-board"></div>
        <p style="font-size:0.8rem; color:#888;">×œ×—×¥ ×¢×œ ×”×œ×•×— ×›×“×™ ×œ×›×•×•×Ÿ ××ª ×”× ×—×©</p>
        <button class="menu-btn back-btn" onclick="endGame()">×™×¦×™××” ×œ×ª×¤×¨×™×˜</button>
    </div>

    <div id="tf-game" class="game-container">
        <h2>×××ª ××• ×©×§×¨?</h2>
        <h2 id="tf-word" style="font-size: 2rem; color:var(--secondary-color); margin:5px;">××™×œ×”</h2>
        <div id="tf-image-container"></div>
        <div class="tf-buttons">
            <button class="tf-btn btn-true" onclick="checkTF(true)">×××ª</button>
            <button class="tf-btn btn-false" onclick="checkTF(false)">×©×§×¨</button>
        </div>
        <button class="menu-btn back-btn" onclick="endGame()">×™×¦×™××” ×œ×ª×¤×¨×™×˜</button>
    </div>

    <div id="memory-game" class="game-container">
        <h2>××©×—×§ ×”×–×™×›×¨×•×Ÿ</h2>
        <p>×”×ª×× ×‘×™×Ÿ ××™×œ×” ×œ×ª××•× ×”</p>
        <div id="memory-board" class="memory-grid"></div>
        <button class="menu-btn back-btn" onclick="endGame()">×™×¦×™××” ×œ×ª×¤×¨×™×˜</button>
    </div>

    <audio id="chew-sound" src="https://www.soundjay.com/human/sounds/eating-chip-1.mp3"></audio>
    <audio id="success-sound" src="https://www.soundjay.com/misc/sounds/bell-ringing-05.mp3"></audio>

<script>
    // --- × ×ª×•× ×™× ---
    const allWords = [
        { id: 1, word: "×‘×™×ª", image: "https://cdn-icons-png.flaticon.com/512/619/619032.png" },
        { id: 2, word: "×œ×‘", image: "https://cdn-icons-png.flaticon.com/512/833/833472.png" },
        { id: 3, word: "×›×œ×‘", image: "https://cdn-icons-png.flaticon.com/512/616/616408.png" },
        { id: 4, word: "×—×ª×•×œ", image: "https://cdn-icons-png.flaticon.com/512/616/616430.png" },
        { id: 5, word: "×©××©", image: "https://cdn-icons-png.flaticon.com/512/869/869869.png" },
        { id: 6, word: "×¢×¥", image: "https://cdn-icons-png.flaticon.com/512/490/490091.png" },
        { id: 7, word: "××›×•× ×™×ª", image: "https://cdn-icons-png.flaticon.com/512/741/741407.png" },
        { id: 8, word: "×›×“×•×¨", image: "https://cdn-icons-png.flaticon.com/512/326/326031.png" }
    ];

    let activeWords = [];
    let knownWords = JSON.parse(localStorage.getItem('knownWords')) || [];
    let isProgressive = localStorage.getItem('isProgressive') === 'true';

    updateSettingsUI();
    updateProgressBar();

    // --- ××¢×¨×›×ª ×›×œ×œ×™×ª ---

    function playSound(id) {
        const audio = document.getElementById(id);
        if(audio) { audio.currentTime = 0; audio.play().catch(e=>{}); }
    }

    function updateProgressBar() {
        const total = allWords.length;
        const known = knownWords.length;
        const percentage = total === 0 ? 0 : Math.round((known / total) * 100);
        const fillEl = document.getElementById('progress-fill');
        fillEl.style.width = percentage + '%';
        fillEl.innerText = percentage + '%';
        if (percentage === 100) fillEl.innerText = "×”×•×©×œ×! ğŸ†";
    }

    function shuffleArray(array) {
        return array.sort(() => Math.random() - 0.5);
    }

    function prepareGameWords(minNeeded = 1) {
        let pool = allWords;
        if (isProgressive) {
            pool = allWords.filter(w => !knownWords.includes(w.id));
        }
        
        // ×× ××™×Ÿ ××¡×¤×™×§ ××™×œ×™× (×œ××©×œ × ×©××¨ ×¨×§ 1 ×•×¦×¨×™×š 2), × ×™×§×— ×’× ×™×“×•×¢×•×ª
        if (pool.length < minNeeded) {
             if (isProgressive && pool.length === 0) {
                 alert("×›×œ ×”×›×‘×•×“! ×¡×™×™××ª ××ª ×›×œ ×”××™×œ×™×. × ××¤×¡ ×œ×¦×•×¨×š ×ª×¨×’×•×œ.");
                 // ×›××Ÿ ××•×¤×¦×™×•× ×œ×™: ××¤×©×¨ ×œ××¤×¡ ××•×˜×•××˜×™×ª ××• ×¨×§ ×œ×”×•×“×™×¢
             }
             // ×× ×—×¡×¨ ××™×œ×™× ×œ××©×—×§, × ×©×œ×™× ××”×××’×¨ ×”×›×œ×œ×™ ×›×“×™ ×©×”××©×—×§ ×™×¢×‘×•×“
             const needed = minNeeded - pool.length;
             const extras = allWords.filter(w => !pool.includes(w)).slice(0, needed);
             pool = pool.concat(extras);
        }
        
        activeWords = shuffleArray([...pool]);
        return activeWords.length > 0;
    }

    function markWordAsKnown(wordId) {
        if (isProgressive && !knownWords.includes(wordId)) {
            knownWords.push(wordId);
            localStorage.setItem('knownWords', JSON.stringify(knownWords));
            updateProgressBar();
        }
    }

    // --- × ×™×•×•×˜ ---
    function showMainMenu() {
        document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));
        document.getElementById('main-menu').classList.add('active');
        stopSnake();
    }

    function showSettings() {
        document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));
        document.getElementById('settings-screen').classList.add('active');
        updateSettingsUI();
    }

    function endGame() { showMainMenu(); }

    function toggleProgressiveMode() {
        const toggle = document.getElementById('progressive-toggle');
        isProgressive = toggle.checked;
        localStorage.setItem('isProgressive', isProgressive);
        updateSettingsUI();
    }

    function updateSettingsUI() {
        document.getElementById('progressive-toggle').checked = isProgressive;
        const resetBtn = document.getElementById('reset-progress-btn');
        resetBtn.disabled = !isProgressive;
        resetBtn.style.opacity = isProgressive ? "1" : "0.5";
    }

    function resetProgress() {
        if (confirm("×”×× ×œ××¤×¡ ××ª ×”×”×ª×§×“××•×ª?")) {
            knownWords = [];
            localStorage.setItem('knownWords', JSON.stringify(knownWords));
            updateProgressBar();
        }
    }

    function showGame(type) {
        document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));
        
        if (type === 'truefalse') {
            prepareGameWords(1);
            document.getElementById('tf-game').classList.add('active');
            nextTFRound();
        } else if (type === 'snake') {
            prepareGameWords(1);
            document.getElementById('snake-game').classList.add('active');
            initSnakeGame();
        } else if (type === 'memory') {
            // ×œ××©×—×§ ×”×–×™×›×¨×•×Ÿ ×¦×¨×™×š ×œ×¤×—×•×ª 6 ×–×•×’×•×ª ×›×“×™ ×©×™×”×™×” ××¢× ×™×™×Ÿ, ××• ××” ×©×™×©
            prepareGameWords(6); 
            document.getElementById('memory-game').classList.add('active');
            initMemoryGame();
        }
    }

    // --- ×××ª ××• ×©×§×¨ ---
    let currentTFWord, isCorrectTF;
    function nextTFRound() {
        if (activeWords.length === 0) { prepareGameWords(1); } // ×¨×™×¤×™×œ ×× × ×’××¨
        currentTFWord = activeWords[0];
        isCorrectTF = Math.random() < 0.5;
        
        let displayImage = isCorrectTF ? currentTFWord.image : 
            allWords.filter(w => w.id !== currentTFWord.id)[Math.floor(Math.random()*(allWords.length-1))].image;

        document.getElementById('tf-word').innerText = currentTFWord.word;
        const container = document.getElementById('tf-image-container');
        container.innerHTML = `<img src="${displayImage}" alt="game image">`;
    }

    function checkTF(answer) {
        if (answer === isCorrectTF) {
            playSound('success-sound');
            markWordAsKnown(currentTFWord.id);
            activeWords.shift();
            setTimeout(nextTFRound, 500);
        } else {
            alert("×œ× × ×›×•×Ÿ, × ×¡×” ×©×•×‘");
            activeWords.push(activeWords.shift());
            nextTFRound();
        }
    }

    // --- ××©×—×§ ×”×–×™×›×¨×•×Ÿ (Logic) ---
    let memoryBoard = document.getElementById('memory-board');
    let cards = [];
    let hasFlippedCard = false;
    let lockBoard = false;
    let firstCard, secondCard;

    function initMemoryGame() {
        memoryBoard.innerHTML = '';
        // ×‘×•×—×¨×™× 6 ××™×œ×™× (××• ×¤×—×•×ª ×× ××™×Ÿ)
        let gameSet = activeWords.slice(0, 6); 
        
        // ×™×¦×™×¨×ª ×–×•×’×•×ª: ××—×“ ×¢× ×˜×§×¡×˜, ××—×“ ×¢× ×ª××•× ×”
        let deck = [];
        gameSet.forEach(item => {
            deck.push({ id: item.id, type: 'text', content: item.word });
            deck.push({ id: item.id, type: 'img', content: item.image });
        });
        
        shuffleArray(deck);

        deck.forEach(item => {
            const card = document.createElement('div');
            card.classList.add('memory-card');
            card.dataset.id = item.id;
            
            // ×ª×•×›×Ÿ ×”×›×¨×˜×™×¡ (××•×¡×ª×¨ ×‘×”×ª×—×œ×” ×¢"×™ CSS ×©×œ flipped)
            if (item.type === 'text') {
                card.innerHTML = `<span style="display:none;">${item.content}</span>`;
            } else {
                card.innerHTML = `<img src="${item.content}" style="display:none;">`;
            }
            
            card.addEventListener('click', flipCard);
            memoryBoard.appendChild(card);
        });
    }

    function flipCard() {
        if (lockBoard) return;
        if (this === firstCard) return;

        this.classList.add('flipped');
        // ××¦×™×’×™× ××ª ×”×ª×•×›×Ÿ
        this.children[0].style.display = 'block';

        if (!hasFlippedCard) {
            hasFlippedCard = true;
            firstCard = this;
            return;
        }

        secondCard = this;
        checkForMatch();
    }

    function checkForMatch() {
        let isMatch = firstCard.dataset.id === secondCard.dataset.id;
        isMatch ? disableCards() : unflipCards();
    }

    function disableCards() {
        playSound('success-sound');
        // ××¡×× ×™× ×›×œ××™×“×”
        markWordAsKnown(parseInt(firstCard.dataset.id));
        
        firstCard.classList.add('matched');
        secondCard.classList.add('matched');
        resetBoard();
        
        // ×‘×“×™×§×” ×× × ×’××¨ ×”××©×—×§
        if (document.querySelectorAll('.matched').length === document.querySelectorAll('.memory-card').length) {
            setTimeout(() => alert("×›×œ ×”×›×‘×•×“! ×¡×™×™××ª ××ª ×”×œ×•×—."), 500);
        }
    }

    function unflipCards() {
        lockBoard = true;
        setTimeout(() => {
            firstCard.classList.remove('flipped');
            secondCard.classList.remove('flipped');
            firstCard.children[0].style.display = 'none';
            secondCard.children[0].style.display = 'none';
            resetBoard();
        }, 1000);
    }

    function resetBoard() {
        [hasFlippedCard, lockBoard] = [false, false];
        [firstCard, secondCard] = [null, null];
    }

    // --- ×¡× ×™×™×§ ---
    let snake, direction, food, gameInterval;
    const box = 20;

    function initSnakeGame() {
        snake = [{x: 140, y: 140}];
        direction = "RIGHT";
        spawnSnakeFood();
        document.addEventListener('keydown', changeSnakeDirection);
        document.getElementById('snake-board').addEventListener('click', handleTouchSnake);
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(drawSnake, 200);
    }

    function stopSnake() {
        if (gameInterval) clearInterval(gameInterval);
        document.removeEventListener('keydown', changeSnakeDirection);
        document.getElementById('snake-board').removeEventListener('click', handleTouchSnake);
    }

    function spawnSnakeFood() {
        if(activeWords.length === 0) activeWords = shuffleArray([...allWords]);
        
        const wordObj = activeWords[Math.floor(Math.random() * activeWords.length)];
        document.getElementById('target-word-snake').innerText = wordObj.word;
        
        food = {
            x: Math.floor(Math.random() * (300/box)) * box,
            y: Math.floor(Math.random() * (300/box)) * box,
            obj: wordObj
        };
    }

    function changeSnakeDirection(event) {
        const key = event.keyCode;
        if (key == 37 && direction != "RIGHT") direction = "LEFT";
        else if (key == 38 && direction != "DOWN") direction = "UP";
        else if (key == 39 && direction != "LEFT") direction = "RIGHT";
        else if (key == 40 && direction != "UP") direction = "DOWN";
    }

    function handleTouchSnake(e) {
        const rect = e.target.getBoundingClientRect();
        const x = e.clientX - rect.left; 
        const y = e.clientY - rect.top;
        const head = snake[0];
        
        if (Math.abs(x - head.x) > Math.abs(y - head.y)) {
             direction = (x > head.x) ? "RIGHT" : "LEFT";
        } else {
             direction = (y > head.y) ? "DOWN" : "UP";
        }
    }

    function drawSnake() {
        const board = document.getElementById('snake-board');
        board.innerHTML = ''; 

        // Draw Food
        const foodDiv = document.createElement('div');
        foodDiv.className = 'food-item';
        foodDiv.style.left = food.x + 'px';
        foodDiv.style.top = food.y + 'px';
        board.appendChild(foodDiv);

        // Move Head
        let snakeX = snake[0].x;
        let snakeY = snake[0].y;

        if (direction == "LEFT") snakeX -= box;
        if (direction == "UP") snakeY -= box;
        if (direction == "RIGHT") snakeX += box;
        if (direction == "DOWN") snakeY += box;

        // Check Eat
        if (snakeX == food.x && snakeY == food.y) {
            playSound('chew-sound');
            markWordAsKnown(food.obj.id);
            // ××¡×™×¨×™× ××”×¨×©×™××” ×¨×§ ×× ×–×” ×¤×¨×•×’×¨×¡×™×‘×™, ××—×¨×ª ×–×” ×¡×ª× ×¨× ×“×•××œ×™
            if(isProgressive) activeWords = activeWords.filter(w => w.id !== food.obj.id);
            spawnSnakeFood();
        } else {
            snake.pop(); 
        }

        // Check Collision
        if (snakeX < 0 || snakeX >= 300 || snakeY < 0 || snakeY >= 300 || 
            snake.some(part => part.x === snakeX && part.y === snakeY)) {
            snake = [{x: 140, y: 140}];
            return;
        }

        snake.unshift({x: snakeX, y: snakeY});

        // Draw Snake
        snake.forEach(part => {
            const p = document.createElement('div');
            p.className = 'snake-part';
            p.style.left = part.x + 'px';
            p.style.top = part.y + 'px';
            board.appendChild(p);
        });
    }
</script>
</body>
</html>
