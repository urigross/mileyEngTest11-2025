<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jet 2 - ××©×—×§ ×”×›× ×” ×œ××‘×—×Ÿ (××•×¨×—×‘)</title>
    <style>
        :root {
            --primary: #4a90e2;
            --secondary: #f5a623;
            --success: #7ed321;
            --error: #d0021b;
            --bg: #f0f4f8;
            --card: #ffffff;
            --dark: #2c3e50;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            margin: 0;
            padding: 10px;
            text-align: center;
            direction: rtl;
            overflow-x: hidden;
            user-select: none; /* Prevent selection on touch */
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--card);
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            padding: 20px;
            min-height: 600px;
            position: relative;
        }

        h1 { color: var(--primary); margin: 10px 0; font-size: 1.8rem; }
        h2 { color: #555; font-size: 1.2rem; margin-top: 0; }

        .score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--secondary);
            color: white;
            padding: 8px 15px;
            border-radius: 50px;
            font-weight: bold;
            font-size: 1.1rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .game-screen { display: none; }
        .game-screen.active { display: block; animation: fadeIn 0.5s; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Buttons Grid */
        .menu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            padding: 20px;
        }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 20px 10px;
            font-size: 1.1rem;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 5px 0 #357abd;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn i { font-size: 2rem; font-style: normal; }
        .btn:active { transform: translateY(4px); box-shadow: none; }
        .btn:hover { background: #357abd; }
        .btn-secondary { background: var(--secondary); box-shadow: 0 5px 0 #d48e15; width: auto; display: inline-block; padding: 10px 30px;}
        .btn-game-control { padding: 10px 20px; font-size: 1rem; margin: 10px; width: auto; display: inline-block;}

        /* Standard Game Elements */
        .emoji-display { font-size: 4rem; margin: 10px 0; display: block; }
        .word-options { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; margin-top: 20px; }
        
        .listening-btn {
            font-size: 2.5rem;
            background: white;
            border: 2px solid #ddd;
            border-radius: 15px;
            padding: 15px;
            cursor: pointer;
            transition: 0.3s;
            min-width: 80px;
        }
        .listening-btn:hover { background: #eef; border-color: var(--primary); transform: scale(1.1); }

        .input-box {
            font-size: 1.5rem;
            padding: 10px;
            border: 3px solid #ccc;
            border-radius: 10px;
            width: 80%;
            max-width: 300px;
            text-align: center;
            outline: none;
            margin-bottom: 20px;
        }
        .input-box:focus { border-color: var(--primary); }

        .feedback {
            font-size: 1.3rem;
            margin-top: 15px;
            font-weight: bold;
            min-height: 30px;
        }
        .feedback.correct { color: var(--success); }
        .feedback.wrong { color: var(--error); }

        /* Reading Section */
        .reading-text {
            background: #fff;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ddd;
            border-left: 5px solid var(--primary);
            text-align: left;
            font-size: 1.1rem;
            line-height: 1.5;
            margin-bottom: 20px;
            direction: ltr;
            max-height: 200px;
            overflow-y: auto;
        }

        /* --- SNAKE GAME STYLES --- */
        #snake-canvas {
            background-color: #2c3e50;
            border-radius: 10px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            display: block;
            margin: 10px auto;
            max-width: 100%;
        }
        
        .snake-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .d-pad-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #ddd;
            border: none;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px #bbb;
        }
        .d-pad-btn:active { transform: translateY(4px); box-shadow: none; }
        #snake-word-target {
            font-size: 1.5rem;
            letter-spacing: 5px;
            color: var(--primary);
            font-weight: bold;
            direction: ltr;
            margin-bottom: 10px;
        }
        .missing-letter { color: #ccc; border-bottom: 2px solid #ccc; display: inline-block; width: 20px; text-align: center;}
        .found-letter { color: var(--success); border-bottom: 2px solid var(--success); display: inline-block; width: 20px; text-align: center;}

        /* --- MEMORY GAME STYLES --- */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
        }
        .memory-card {
            aspect-ratio: 1;
            background: var(--primary);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.5s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .memory-card.flipped { transform: rotateY(180deg); background: white; cursor: default; }
        .memory-card-content {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem; /* Adjusted for longer words */
            font-weight: bold;
            backface-visibility: hidden;
            text-align: center;
            padding: 5px;
            box-sizing: border-box;
            transform: rotateY(180deg); /* Content is on the back */
            color: #333;
            word-break: break-word;
        }
        .memory-card-front {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: rgba(255,255,255,0.5);
        }

        /* VICTORY OVERLAY */
        #victory-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        #victory-overlay h1 { font-size: 3rem; color: #f2d74e; text-shadow: 0 0 20px #f2d74e; margin-bottom: 0; }
        #victory-overlay p { font-size: 1.5rem; margin-top: 10px; }
        #fireworks-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

    </style>
</head>
<body>

<div class="container">
    <div class="score-board">× ×™×§×•×“: <span id="currentScore">0</span></div>
    
    <div id="screen-menu" class="game-screen active">
        <h1>ğŸ“ ×”×›× ×” ×œ××‘×—×Ÿ ×‘×× ×’×œ×™×ª - ×›×™×ª×” ×“'</h1>
        <h2>At School - Unit 1</h2>
        <p>×‘×—×¨×™ ××©×—×§ ×›×“×™ ×œ×”×ª×—×™×œ:</p>
        
        <div class="menu-grid">
            <button class="btn" onclick="startGame('listening')"><i>ğŸ‘‚</i>×”×‘× ×ª ×”× ×©××¢</button>
            <button class="btn" onclick="startGame('vocab')"><i>âœï¸</i>×›×ª×™×‘×ª ××™×œ×™×</button>
            <button class="btn" onclick="startGame('sentences')"><i>ğŸ§©</i>×”×©×œ××ª ××©×¤×˜×™×</button>
            <button class="btn" onclick="startGame('reading')"><i>ğŸ“–</i>×”×‘× ×ª ×”× ×§×¨×</button>
            <button class="btn" style="background-color: #9b59b6;" onclick="startSnakeGame()"><i>ğŸ</i>×¡× ×™×™×§ ××™×œ×™×</button>
            <button class="btn" style="background-color: #e67e22;" onclick="startMemoryGame()"><i>ğŸƒ</i>××©×—×§ ×”×–×™×›×¨×•×Ÿ</button>
        </div>
        
        <button class="btn btn-secondary" onclick="showLeaderboard()">ğŸ† ×œ×•×— ×”×©×™××™×</button>
    </div>

    <div id="screen-game" class="game-screen">
        <div id="category-title" style="margin-bottom: 10px; font-weight: bold; color: #777;"></div>
        <div id="game-content"></div>
        <div id="feedback" class="feedback"></div>
        <button class="btn btn-game-control" id="next-btn" style="display:none;" onclick="nextQuestion()">×”×‘×</button>
        <button class="btn btn-secondary" onclick="showMenu()">×™×¦×™××” ×œ×ª×¤×¨×™×˜</button>
    </div>

    <div id="screen-snake" class="game-screen">
        <h2>ğŸ ×¡× ×™×™×§ ××™×œ×™×: ××›×œ×™ ××ª ×”××•×ª×™×•×ª ×œ×¤×™ ×”×¡×“×¨!</h2>
        <div id="snake-word-target"></div>
        <canvas id="snake-canvas" width="400" height="300"></canvas>
        <div class="snake-controls">
            <button class="d-pad-btn" onmousedown="setSnakeDir('LEFT')">â¬…ï¸</button>
            <div style="display:flex; flex-direction:column; gap:10px">
                <button class="d-pad-btn" onmousedown="setSnakeDir('UP')">â¬†ï¸</button>
                <button class="d-pad-btn" onmousedown="setSnakeDir('DOWN')">â¬‡ï¸</button>
            </div>
            <button class="d-pad-btn" onmousedown="setSnakeDir('RIGHT')">â¡ï¸</button>
        </div>
        <button class="btn btn-secondary" style="margin-top:20px" onclick="stopSnakeGame()">×™×¦×™××”</button>
    </div>

    <div id="screen-memory" class="game-screen">
        <h2>ğŸƒ ××©×—×§ ×”×–×™×›×¨×•×Ÿ: ×”×ª××™××™ ××™×œ×” ×œ×¤×™×¨×•×©</h2>
        <div id="memory-board" class="memory-grid"></div>
        <button class="btn btn-secondary" style="margin-top:20px" onclick="showMenu()">×™×¦×™××”</button>
    </div>

    <div id="screen-leaderboard" class="game-screen">
        <h1>ğŸ† ××œ×•×¤×™ ×”×× ×’×œ×™×ª</h1>
        <ul id="scores-list" style="list-style: none; padding: 0;"></ul>
        <button class="btn btn-secondary" onclick="showMenu()">×—×–×¨×”</button>
    </div>
</div>

<div id="victory-overlay" onclick="closeVictory()">
    <canvas id="fireworks-canvas"></canvas>
    <h1>ğŸ† ×›×œ ×”×›×‘×•×“! ğŸ†</h1>
    <p>×‘×¨×›×•×ª! ×©×‘×¨×ª ×©×™× ×—×“×©!</p>
    <p style="font-size: 1rem; color: #ddd;">(×œ×—×¦×™ ×›×“×™ ×œ×”××©×™×š)</p>
</div>

<script>
    // --- Data ---
    const vocabulary = [
        { word: "school", icon: "ğŸ«", hebrew: "×‘×™×ª ×¡×¤×¨" },
        { word: "teacher", icon: "ğŸ‘©â€ğŸ«", hebrew: "××•×¨×”" },
        { word: "pupil", icon: "ğŸ‘§", hebrew: "×ª×œ××™×“/×”" },
        { word: "friend", icon: "ğŸ‘«", hebrew: "×—×‘×¨/×”" },
        { word: "family", icon: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦", hebrew: "××©×¤×—×”" },
        { word: "book", icon: "ğŸ“–", hebrew: "×¡×¤×¨" },
        { word: "notebook", icon: "ğŸ““", hebrew: "××—×‘×¨×ª" },
        { word: "pencil", icon: "âœï¸", hebrew: "×¢×™×¤×¨×•×Ÿ" },
        { word: "eraser", icon: "ğŸ§¼", hebrew: "××—×§" },
        { word: "computer", icon: "ğŸ’»", hebrew: "××—×©×‘" },
        { word: "lunch", icon: "ğŸ¥ª", hebrew: "××¨×•×—×ª ×¦×”×¨×™×™×" },
        { word: "bird", icon: "ğŸ¦", hebrew: "×¦×™×¤×•×¨" },
        { word: "house", icon: "ğŸ ", hebrew: "×‘×™×ª" },
        { word: "math", icon: "â—", hebrew: "×—×©×‘×•×Ÿ" },
        { word: "art", icon: "ğŸ¨", hebrew: "××•×× ×•×ª" },
        { word: "music", icon: "ğŸµ", hebrew: "××•×–×™×§×”" },
        { word: "sports", icon: "âš½", hebrew: "×¡×¤×•×¨×˜" },
        { word: "happy", icon: "ğŸ˜Š", hebrew: "×©××—" },
        { word: "write", icon: "âœï¸", hebrew: "×œ×›×ª×•×‘" },
        { word: "homework", icon: "ğŸ ğŸ“š", hebrew: "×©×™×¢×•×¨×™ ×‘×™×ª" },
        { word: "brother", icon: "ğŸ‘¦", hebrew: "××—" },
        { word: "sister", icon: "ğŸ‘§", hebrew: "××—×•×ª" },
        { word: "english", icon: "ğŸ”¤", hebrew: "×× ×’×œ×™×ª" },
        { word: "new", icon: "âœ¨", hebrew: "×—×“×©" }
    ];

    const sentences = [
        { text: "The _____ is on the table.", options: ["book", "fly"], answer: "book" },
        { text: "I like my _____. She is nice.", options: ["teacher", "day"], answer: "teacher" },
        { text: "We learn _____ at school.", options: ["English", "lunch"], answer: "English" },
        { text: "I have a sandwich for _____.", options: ["lunch", "pencil"], answer: "lunch" },
        { text: "This is my _____, Dan.", options: ["brother", "board"], answer: "brother" },
        { text: "Please _____ your name.", options: ["write", "happy"], answer: "write" },
        { text: "I live in a big _____.", options: ["house", "chair"], answer: "house" },
        { text: "The _____ is singing.", options: ["bird", "book"], answer: "bird" }
    ];

    const readingText = `
        Hi! My name is Gal. I am 9 years old.
        I am a pupil in grade 4.
        I learn at a big school in the town.
        My teacher is Rina. She is very nice.
        I like Math, English and Sports.
        I have a new computer at home.
    `;

    const readingQuestions = [
        { q: "What is the girl's name?", options: ["Rina", "Gal", "Tal"], answer: "Gal" },
        { q: "What grade is she in?", options: ["Grade 3", "Grade 5", "Grade 4"], answer: "Grade 4" },
        { q: "What is the teacher's name?", options: ["Rina", "Gal", "Dana"], answer: "Rina" },
        { q: "What does she have at home?", options: ["A bird", "A new computer", "A dog"], answer: "A new computer" }
    ];

    // --- State ---
    let score = 0;
    let currentMode = '';
    let currentQuestionIndex = 0;
    let currentData = [];

    // --- Audio Context for Fanfare ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;

    function initAudio() {
        if (!audioCtx) audioCtx = new AudioContext();
    }

    function playTone(freq, duration, type = 'sine') {
        initAudio();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
        osc.stop(audioCtx.currentTime + duration);
    }

    function playVictoryFanfare() {
        // Simple fanfare sequence
        const now = audioCtx ? audioCtx.currentTime : 0;
        setTimeout(() => playTone(523.25, 0.2, 'square'), 0);   // C5
        setTimeout(() => playTone(523.25, 0.2, 'square'), 200); // C5
        setTimeout(() => playTone(523.25, 0.2, 'square'), 400); // C5
        setTimeout(() => playTone(659.25, 0.6, 'square'), 600); // E5
        setTimeout(() => playTone(523.25, 0.2, 'square'), 900); // C5
        setTimeout(() => playTone(783.99, 1.0, 'square'), 1100); // G5
    }

    // --- Core Functions ---

    function speak(text) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
    }

    function switchScreen(id) {
        document.querySelectorAll('.game-screen').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        // Stop snake if leaving snake screen
        if (id !== 'screen-snake') snakeGame.running = false;
    }

    function updateScoreDisplay() {
        document.getElementById('currentScore').innerText = score;
    }

    function showMenu() {
        switchScreen('screen-menu');
    }

    // --- Standard Games Logic ---

    function startGame(mode) {
        currentMode = mode;
        score = 0;
        currentQuestionIndex = 0;
        updateScoreDisplay();
        switchScreen('screen-game');
        
        let title = "";
        if (mode === 'listening') title = "×”×§×©×™×‘×™ ×•×œ×—×¦×™ ×¢×œ ×”×ª××•× ×” ×”× ×›×•× ×”";
        if (mode === 'vocab') title = "×›×ª×‘×™ ××ª ×”××™×œ×” ×‘×× ×’×œ×™×ª";
        if (mode === 'sentences') title = "×”×©×œ×™××™ ××ª ×”××©×¤×˜";
        if (mode === 'reading') title = "×§×¨××™ ××ª ×”×˜×§×¡×˜ ×•×¢× ×™ ×¢×œ ×”×©××œ×•×ª";
        
        document.getElementById('category-title').innerText = title;
        generateLevelData();
        renderQuestion();
    }

    function generateLevelData() {
        if (currentMode === 'listening' || currentMode === 'vocab') {
            currentData = [...vocabulary].sort(() => 0.5 - Math.random()).slice(0, 10);
        } else if (currentMode === 'sentences') {
            currentData = [...sentences].sort(() => 0.5 - Math.random()).slice(0, 8);
        } else if (currentMode === 'reading') {
            currentData = [...readingQuestions]; 
        }
    }

    function renderQuestion() {
        const container = document.getElementById('game-content');
        const feedback = document.getElementById('feedback');
        const nextBtn = document.getElementById('next-btn');
        
        container.innerHTML = '';
        feedback.innerText = '';
        feedback.className = 'feedback';
        nextBtn.style.display = 'none';

        if (currentQuestionIndex >= currentData.length) {
            endGame();
            return;
        }

        const item = currentData[currentQuestionIndex];

        // --- Listening ---
        if (currentMode === 'listening') {
            let options = [item];
            while(options.length < 3) {
                let r = vocabulary[Math.floor(Math.random() * vocabulary.length)];
                if (!options.includes(r)) options.push(r);
            }
            options.sort(() => 0.5 - Math.random());

            const btnSpeak = document.createElement('button');
            btnSpeak.className = 'btn btn-secondary';
            btnSpeak.innerText = 'ğŸ”Š ×”×©××™×¢×™ ××™×œ×”';
            btnSpeak.onclick = () => speak(item.word);
            setTimeout(() => speak(item.word), 500);

            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'word-options';
            options.forEach(opt => {
                const b = document.createElement('div');
                b.className = 'listening-btn';
                b.innerText = opt.icon;
                b.onclick = () => checkAnswer(opt.word, item.word);
                optionsDiv.appendChild(b);
            });
            container.appendChild(btnSpeak);
            container.appendChild(optionsDiv);
        }

        // --- Vocab ---
        if (currentMode === 'vocab') {
            const icon = document.createElement('div');
            icon.className = 'emoji-display';
            icon.innerText = item.icon;
            
            const hint = document.createElement('div');
            hint.innerText = item.hebrew;
            hint.style.fontSize = "1.2rem";
            hint.style.marginBottom = "10px";

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'input-box';
            input.placeholder = 'Type here...';
            input.autocomplete = "off";
            input.onkeypress = (e) => { if(e.key === 'Enter') checkAnswer(input.value, item.word); };

            const checkBtn = document.createElement('button');
            checkBtn.className = 'btn';
            checkBtn.innerText = '×‘×“×™×§×”';
            checkBtn.onclick = () => checkAnswer(input.value, item.word);

            container.appendChild(icon);
            container.appendChild(hint);
            container.appendChild(input);
            container.appendChild(checkBtn);
            input.focus();
        }

        // --- Sentences ---
        if (currentMode === 'sentences') {
            const sentenceDiv = document.createElement('div');
            sentenceDiv.style.fontSize = "1.5rem";
            sentenceDiv.style.marginBottom = "20px";
            sentenceDiv.style.direction = "ltr";
            sentenceDiv.innerText = item.text;

            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'word-options';
            item.options.forEach(opt => {
                const b = document.createElement('button');
                b.className = 'btn';
                b.innerText = opt;
                b.onclick = () => checkAnswer(opt, item.answer);
                optionsDiv.appendChild(b);
            });
            container.appendChild(sentenceDiv);
            container.appendChild(optionsDiv);
        }

        // --- Reading ---
        if (currentMode === 'reading') {
            const textDiv = document.createElement('div');
            textDiv.className = 'reading-text';
            textDiv.innerText = readingText;

            const qDiv = document.createElement('div');
            qDiv.className = 'question-box';
            qDiv.style.direction = "ltr";
            qDiv.innerHTML = `<h3>${item.q}</h3>`;

            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'word-options';
            item.options.forEach(opt => {
                const b = document.createElement('button');
                b.className = 'btn';
                b.innerText = opt;
                b.onclick = () => checkAnswer(opt, item.answer);
                optionsDiv.appendChild(b);
            });
            container.appendChild(textDiv);
            container.appendChild(qDiv);
            container.appendChild(optionsDiv);
        }
    }

    function checkAnswer(userAnswer, correctAnswer) {
        if (document.getElementById('next-btn').style.display === 'inline-block') return;

        const feedback = document.getElementById('feedback');
        userAnswer = userAnswer.trim().toLowerCase();
        correctAnswer = correctAnswer.trim().toLowerCase();

        if (userAnswer === correctAnswer) {
            feedback.innerText = "Excellent! ×›×œ ×”×›×‘×•×“!";
            feedback.className = "feedback correct";
            score += 10;
            speak("Good job!");
        } else {
            feedback.innerText = `×”×ª×©×•×‘×” ×”× ×›×•× ×” ×”×™×: ${correctAnswer}`;
            feedback.className = "feedback wrong";
            speak("Try again");
        }
        updateScoreDisplay();
        document.getElementById('next-btn').style.display = 'inline-block';
    }

    function nextQuestion() {
        currentQuestionIndex++;
        renderQuestion();
    }

    // --- SNAKE GAME LOGIC ---
    const snakeGame = {
        canvas: null,
        ctx: null,
        grid: 20,
        running: false,
        snake: [],
        items: [],
        dx: 0,
        dy: 0,
        wordData: null,
        targetWord: "",
        currentLetterIndex: 0,
        loopId: null,
        speed: 150
    };

    function startSnakeGame() {
        currentMode = 'snake';
        score = 0;
        updateScoreDisplay();
        switchScreen('screen-snake');
        
        snakeGame.canvas = document.getElementById('snake-canvas');
        snakeGame.ctx = snakeGame.canvas.getContext('2d');
        
        // Setup Grid size relative to canvas
        snakeGame.grid = 20;
        
        // Init Game
        nextSnakeLevel();
        snakeGame.running = true;
        
        // Input Handling
        document.addEventListener('keydown', handleSnakeKey);
        
        if (snakeGame.loopId) clearInterval(snakeGame.loopId);
        snakeGame.loopId = setInterval(gameLoop, snakeGame.speed);
    }

    function stopSnakeGame() {
        snakeGame.running = false;
        clearInterval(snakeGame.loopId);
        document.removeEventListener('keydown', handleSnakeKey);
        endGame();
    }

    function nextSnakeLevel() {
        // Pick random word
        snakeGame.wordData = vocabulary[Math.floor(Math.random() * vocabulary.length)];
        snakeGame.targetWord = snakeGame.wordData.word.toUpperCase();
        snakeGame.currentLetterIndex = 0;
        
        // Reset Snake
        snakeGame.snake = [{x: 160, y: 160}, {x: 140, y: 160}, {x: 120, y: 160}];
        snakeGame.dx = snakeGame.grid;
        snakeGame.dy = 0;
        
        spawnSnakeItems();
        updateSnakeUI();
    }

    function updateSnakeUI() {
        const display = document.getElementById('snake-word-target');
        display.innerHTML = '';
        
        // Show Hebrew hint
        const hint = document.createElement('div');
        hint.style.fontSize = "1rem";
        hint.style.color = "#ccc";
        hint.innerText = snakeGame.wordData.hebrew;
        display.appendChild(hint);

        const wordContainer = document.createElement('div');
        for (let i = 0; i < snakeGame.targetWord.length; i++) {
            const span = document.createElement('span');
            span.innerText = snakeGame.targetWord[i];
            if (i < snakeGame.currentLetterIndex) {
                span.className = 'found-letter';
            } else {
                span.className = 'missing-letter';
                span.innerText = '_'; // Hide future letters
            }
            span.style.margin = "0 5px";
            wordContainer.appendChild(span);
        }
        display.appendChild(wordContainer);
    }

    function spawnSnakeItems() {
        snakeGame.items = [];
        
        // 1. Correct Letter
        const correctChar = snakeGame.targetWord[snakeGame.currentLetterIndex];
        snakeGame.items.push({
            x: getRandomInt(0, 19) * snakeGame.grid,
            y: getRandomInt(0, 14) * snakeGame.grid,
            char: correctChar,
            type: 'correct'
        });

        // 2. Distractor Letter
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let wrongChar = alphabet[Math.floor(Math.random() * alphabet.length)];
        while(wrongChar === correctChar) wrongChar = alphabet[Math.floor(Math.random() * alphabet.length)];
        
        snakeGame.items.push({
            x: getRandomInt(0, 19) * snakeGame.grid,
            y: getRandomInt(0, 14) * snakeGame.grid,
            char: wrongChar,
            type: 'wrong'
        });
    }

    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    function handleSnakeKey(e) {
        // Prevent default scrolling for arrows
        if([37,38,39,40].includes(e.keyCode)) e.preventDefault();
        
        const goingUp = snakeGame.dy === -snakeGame.grid;
        const goingDown = snakeGame.dy === snakeGame.grid;
        const goingRight = snakeGame.dx === snakeGame.grid;
        const goingLeft = snakeGame.dx === -snakeGame.grid;

        if (e.keyCode === 37 && !goingRight) { snakeGame.dx = -snakeGame.grid; snakeGame.dy = 0; }
        if (e.keyCode === 38 && !goingDown) { snakeGame.dx = 0; snakeGame.dy = -snakeGame.grid; }
        if (e.keyCode === 39 && !goingLeft) { snakeGame.dx = snakeGame.grid; snakeGame.dy = 0; }
        if (e.keyCode === 40 && !goingUp) { snakeGame.dx = 0; snakeGame.dy = snakeGame.grid; }
    }

    function setSnakeDir(dir) {
        const goingUp = snakeGame.dy === -snakeGame.grid;
        const goingDown = snakeGame.dy === snakeGame.grid;
        const goingRight = snakeGame.dx === snakeGame.grid;
        const goingLeft = snakeGame.dx === -snakeGame.grid;

        if (dir === 'LEFT' && !goingRight) { snakeGame.dx = -snakeGame.grid; snakeGame.dy = 0; }
        if (dir === 'UP' && !goingDown) { snakeGame.dx = 0; snakeGame.dy = -snakeGame.grid; }
        if (dir === 'RIGHT' && !goingLeft) { snakeGame.dx = snakeGame.grid; snakeGame.dy = 0; }
        if (dir === 'DOWN' && !goingUp) { snakeGame.dx = 0; snakeGame.dy = snakeGame.grid; }
    }

    function gameLoop() {
        if (!snakeGame.running) return;

        // Move Snake
        const head = { x: snakeGame.snake[0].x + snakeGame.dx, y: snakeGame.snake[0].y + snakeGame.dy };
        snakeGame.snake.unshift(head);

        // Check Wall Collision
        if (head.x < 0 || head.x >= snakeGame.canvas.width || head.y < 0 || head.y >= snakeGame.canvas.height) {
            stopSnakeGame();
            return;
        }

        // Check Self Collision (skip head)
        for (let i = 1; i < snakeGame.snake.length; i++) {
            if (head.x === snakeGame.snake[i].x && head.y === snakeGame.snake[i].y) {
                stopSnakeGame();
                return;
            }
        }

        // Check Item Collision
        let ate = false;
        for (let i = 0; i < snakeGame.items.length; i++) {
            let item = snakeGame.items[i];
            // Hitbox check
            if (head.x === item.x && head.y === item.y) {
                if (item.type === 'correct') {
                    // Correct letter!
                    score += 5;
                    updateScoreDisplay();
                    snakeGame.currentLetterIndex++;
                    ate = true; // Grow snake
                    
                    if (snakeGame.currentLetterIndex >= snakeGame.targetWord.length) {
                        // Word Complete!
                        score += 20;
                        updateScoreDisplay();
                        speak(snakeGame.wordData.word);
                        nextSnakeLevel();
                        return; // Skip rest of loop to render new level
                    } else {
                        // Next letter
                        spawnSnakeItems();
                        updateSnakeUI();
                    }
                } else {
                    // Wrong letter!
                    score = Math.max(0, score - 2);
                    updateScoreDisplay();
                    snakeGame.items.splice(i, 1); // Remove wrong item
                    snakeGame.snake.pop(); // Don't grow (actually simulate hitting makes you not grow if we pop below)
                    // Visual feedback could go here
                }
                break;
            }
        }

        if (!ate) {
            snakeGame.snake.pop(); // Remove tail if didn't eat
        }

        // Draw
        snakeGame.ctx.fillStyle = '#2c3e50';
        snakeGame.ctx.fillRect(0, 0, snakeGame.canvas.width, snakeGame.canvas.height);

        // Draw Items
        snakeGame.ctx.font = "16px Arial";
        snakeGame.ctx.textAlign = "center";
        snakeGame.ctx.textBaseline = "middle";
        
        snakeGame.items.forEach(item => {
            snakeGame.ctx.fillStyle = item.type === 'correct' ? '#2ecc71' : '#e74c3c';
            snakeGame.ctx.beginPath();
            snakeGame.ctx.arc(item.x + 10, item.y + 10, 9, 0, 2 * Math.PI);
            snakeGame.ctx.fill();
            snakeGame.ctx.fillStyle = 'white';
            snakeGame.ctx.fillText(item.char, item.x + 10, item.y + 10);
        });

        // Draw Snake
        snakeGame.ctx.fillStyle = '#3498db';
        snakeGame.snake.forEach((part, index) => {
            snakeGame.ctx.fillRect(part.x, part.y, snakeGame.grid - 2, snakeGame.grid - 2);
        });
    }

    // --- MEMORY GAME LOGIC ---
    let memoryState = {
        cards: [],
        flipped: [],
        matches: 0
    };

    function startMemoryGame() {
        currentMode = 'memory';
        score = 0;
        updateScoreDisplay();
        switchScreen('screen-memory');
        
        // Select 6 random pairs
        let selected = [...vocabulary].sort(() => 0.5 - Math.random()).slice(0, 6);
        let deck = [];
        
        selected.forEach(item => {
            // Card 1: Hebrew/Icon
            deck.push({ id: item.word, content: item.hebrew + " " + item.icon, type: 'he' });
            // Card 2: English
            deck.push({ id: item.word, content: item.word, type: 'en' });
        });
        
        deck.sort(() => 0.5 - Math.random());
        
        const board = document.getElementById('memory-board');
        board.innerHTML = '';
        memoryState.cards = deck;
        memoryState.flipped = [];
        memoryState.matches = 0;
        
        deck.forEach((card, index) => {
            const cardEl = document.createElement('div');
            cardEl.className = 'memory-card';
            cardEl.dataset.index = index;
            cardEl.onclick = () => flipCard(index);
            
            const front = document.createElement('div');
            front.className = 'memory-card-front';
            front.innerText = '?';
            
            const back = document.createElement('div');
            back.className = 'memory-card-content';
            back.innerText = card.content;
            
            cardEl.appendChild(front);
            cardEl.appendChild(back);
            board.appendChild(cardEl);
        });
    }

    function flipCard(index) {
        const cardEl = document.getElementById('memory-board').children[index];
        if (cardEl.classList.contains('flipped') || memoryState.flipped.length >= 2) return;
        
        cardEl.classList.add('flipped');
        memoryState.flipped.push({ index, ...memoryState.cards[index] });
        
        if (memoryState.flipped.length === 2) {
            checkMemoryMatch();
        }
    }

    function checkMemoryMatch() {
        const [c1, c2] = memoryState.flipped;
        const board = document.getElementById('memory-board').children;
        
        if (c1.id === c2.id) {
            // Match
            score += 15;
            updateScoreDisplay();
            speak("Good!");
            memoryState.flipped = [];
            memoryState.matches++;
            
            if (memoryState.matches === 6) {
                setTimeout(endGame, 1000);
            }
        } else {
            // No Match
            setTimeout(() => {
                board[c1.index].classList.remove('flipped');
                board[c2.index].classList.remove('flipped');
                memoryState.flipped = [];
            }, 1000);
        }
    }


    // --- High Score System & Celebration ---

    function endGame() {
        // Stop any game loops
        if (currentMode === 'snake') stopSnakeGame(); // Just in case called externally

        const isNewRecord = checkHighScore(score);
        
        const container = document.getElementById(
            currentMode === 'snake' ? 'screen-snake' : 
            (currentMode === 'memory' ? 'screen-memory' : 'game-content')
        );

        // If simple games, replace content. If Snake/Memory, overlay or alert.
        // For consistency, let's use the generic end screen content for simple games
        // and switch screen for canvas games.
        
        if (currentMode === 'snake' || currentMode === 'memory') {
           switchScreen('screen-game'); // Switch to generic screen to show results
        }

        const gameContent = document.getElementById('game-content');
        gameContent.innerHTML = `
            <h2>×¡×™×™××ª ××ª ×”××©×—×§!</h2>
            <div class="emoji-display">ğŸ†</div>
            <h3>×”× ×™×§×•×“ ×©×œ×š: ${score}</h3>
            <p>×©××¨×™ ××ª ×©××š ×‘×œ×•×— ×”×ª×•×¦××•×ª:</p>
            <input type="text" id="playerName" class="input-box" placeholder="×©××š..." style="width:200px">
            <br>
            <button class="btn" onclick="saveToLeaderboard()">×©××•×¨</button>
        `;
        document.getElementById('next-btn').style.display = 'none';
        document.getElementById('feedback').innerText = '';

        if (isNewRecord) {
            celebrateNewRecord();
        }
    }

    function checkHighScore(currentScore) {
        if (currentScore === 0) return false;
        const saved = JSON.parse(localStorage.getItem('englishGameScores')) || [];
        // Filter by current mode
        const modeScores = saved.filter(s => s.mode === currentMode);
        if (modeScores.length === 0) return true; // First time playing this mode
        const maxScore = Math.max(...modeScores.map(s => s.score));
        return currentScore > maxScore;
    }

    function celebrateNewRecord() {
        const overlay = document.getElementById('victory-overlay');
        overlay.style.display = 'flex';
        initAudio();
        playVictoryFanfare();
        startFireworks();
    }

    function closeVictory() {
        document.getElementById('victory-overlay').style.display = 'none';
        stopFireworks();
    }

    function saveToLeaderboard() {
        const name = document.getElementById('playerName').value || "Anonymous";
        const date = new Date().toLocaleDateString('he-IL');
        
        let scores = JSON.parse(localStorage.getItem('englishGameScores')) || [];
        scores.push({ name, score, date, mode: currentMode });
        scores.sort((a, b) => b.score - a.score); // sort all scores high to low
        
        localStorage.setItem('englishGameScores', JSON.stringify(scores));
        showLeaderboard();
    }

    function showLeaderboard() {
        switchScreen('screen-leaderboard');
        const list = document.getElementById('scores-list');
        list.innerHTML = '';
        let scores = JSON.parse(localStorage.getItem('englishGameScores')) || [];

        if (scores.length === 0) {
            list.innerHTML = '<li>×¢×“×™×™×Ÿ ××™×Ÿ ×ª×•×¦××•×ª... ×”×™×™ ×”×¨××©×•× ×” ×œ×©×—×§!</li>';
            return;
        }

        // Show top 10 global (or filter by mode if desired, currently global list)
        scores = scores.slice(0, 10);

        scores.forEach((s, i) => {
            const li = document.createElement('li');
            li.style.padding = "10px";
            li.style.borderBottom = "1px solid #ddd";
            li.style.fontSize = "1.1rem";
            
            let modeIcon = '';
            if (s.mode === 'listening') modeIcon = 'ğŸ‘‚';
            else if (s.mode === 'vocab') modeIcon = 'âœï¸';
            else if (s.mode === 'snake') modeIcon = 'ğŸ';
            else if (s.mode === 'memory') modeIcon = 'ğŸƒ';
            else modeIcon = 'ğŸ§©';

            li.innerHTML = `<strong>#${i+1} ${s.name}</strong> - ${s.score} × ×§' <span title="${s.mode}">${modeIcon}</span>`;
            list.appendChild(li);
        });
    }

    // --- Canvas Fireworks Logic ---
    let fireworksLoop;
    const fwCanvas = document.getElementById('fireworks-canvas');
    const fwCtx = fwCanvas.getContext('2d');
    let particles = [];

    function resizeCanvas() {
        fwCanvas.width = window.innerWidth;
        fwCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    function createFirework(x, y) {
        const count = 30;
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                alpha: 1,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`
            });
        }
    }

    function updateFireworks() {
        fwCtx.globalCompositeOperation = 'destination-out';
        fwCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        fwCtx.fillRect(0, 0, fwCanvas.width, fwCanvas.height);
        fwCtx.globalCompositeOperation = 'lighter';

        particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1; // gravity
            p.alpha -= 0.02;
            fwCtx.fillStyle = p.color;
            fwCtx.globalAlpha = p.alpha;
            fwCtx.beginPath();
            fwCtx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            fwCtx.fill();
            if (p.alpha <= 0) particles.splice(i, 1);
        });

        if (Math.random() < 0.05) {
            createFirework(Math.random() * fwCanvas.width, Math.random() * fwCanvas.height / 2);
        }

        fireworksLoop = requestAnimationFrame(updateFireworks);
    }

    function startFireworks() {
        resizeCanvas();
        particles = [];
        updateFireworks();
    }

    function stopFireworks() {
        cancelAnimationFrame(fireworksLoop);
        fwCtx.clearRect(0, 0, fwCanvas.width, fwCanvas.height);
    }

</script>

</body>
</html>
